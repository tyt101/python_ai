## 对称二叉树

### 思路：
把对称二叉树拆分成两棵树，分别遍历比较 左子树的左和右子树右，左子树的右和右子树的左。

### 实现方法

#### 栈
```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):

    def isSymmetric(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: bool
        """
        if not root: return True
        if root.left and not root.right: return False
        if root.right and not root.left: return False

        stack = []
        stack.append(root.left)
        stack.append(root.right)

        while stack:
            RCur = stack.pop()
            LCur = stack.pop()

            if not RCur and not LCur:
                continue
            if not RCur or not LCur:
                return False
            if RCur.val != LCur.val:
                return False

            stack.append(LCur.left)
            stack.append(RCur.right)
            stack.append(LCur.right)
            stack.append(RCur.left)

        return True
```
#### 递归
```python
class Solution(object):

    def compare(self, rootA, rootB):
        if not rootA and not rootB: return True
        if rootA and not rootB: return False
        if rootB and not rootA: return False
        if rootA.val != rootB.val: return False

        outerCompare = self.compare(rootA.left, rootB.right)
        innerCompare = self.compare(rootA.right, rootB.left)
        return outerCompare and innerCompare

    def isSymmetric(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: bool
        """
        if not root: return True
        return self.compare(root.left, root.right)

```

### 例题

#### 1. 101 相同的树

##### 递归法
```python
class Solution(object):
    def isSameTree(self, p, q):
        """
        :type p: Optional[TreeNode]
        :type q: Optional[TreeNode]
        :rtype: bool
        """
        if not p and not q: return True
        if p and not q: return False
        if q and not p: return False
        if p.val != q.val: return False

        l_same = self.isSameTree(p.left, q.left)
        r_same = self.isSameTree(p.right, q.right)
        return l_same and r_same
```

##### 栈法
```python
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution(object):
    def isSameTree(self, p, q):
        """
        :type p: Optional[TreeNode]
        :type q: Optional[TreeNode]
        :rtype: bool
        """
        if not p and not q: return True
        if p and not q: return False
        if q and not p: return False
        if p.val != q.val: return False

        stack = []
        stack.append(p)
        stack.append(q)

        while stack:
            l = stack.pop()
            r = stack.pop()

            if not l and not r: continue
            if l and not r: return False
            if r and not l: return False
            if l.val != r.val: return False
            stack.append(l.left)
            stack.append(r.left)
            stack.append(l.right)
            stack.append(r.right)
        return True
```

#### 572.另一个树的子树


## 完全二叉树
在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，
并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。

满二叉树的节点个数count = 2^(h)-1
```python
class Solution: 
    def perfectTree(self, root):
        if not root: return 0
        left = root.left
        right = root.right
        leftLen = 0
        rightLen = 0
        while left:
            left = left.left
            leftLen += 1
        while right:
            right = right.right
            righeLen += 1

        if leftLen == rightLen
            return 2 << leftLen - 1
        return self.perfectTree(root.left) + self.perfectTree(root.right) + 1
```

## 平衡二叉树
一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。


### 实现方法
#### 迭代法
思路：写一个求二叉树深度的方法，然后进行后续遍历，处理节点的左右节点，进行比较abs差值是否大于1.
```python
class Solution:
    def getDepth(self, cur):
        st = []
        if cur is not None:
            st.append(cur)
        depth = 0
        result = 0
        while st:
            node = st[-1]
            if node is not None:
                st.pop()
                st.append(node)                           # 中
                st.append(None)
                depth += 1
                if node.right:
                    st.append(node.right)                 # 右
                if node.left:
                    st.append(node.left)                   # 左

            else:               
                node = st.pop()
                st.pop()
                depth -= 1
            result = max(result, depth)
        return result

    def isBalanced(self, root):
        st = []
        if root is None:
            return True
        st.append(root)
        while st:
            node = st.pop()                                 # 中
            if abs(self.getDepth(node.left) - self.getDepth(node.right)) > 1:
                return False
            if node.right:
                st.append(node.right)                       # 右（空节点不入栈）
            if node.left:
                st.append(node.left)                         # 左（空节点不入栈）
        return True

```
#### 递归法

```python
class Solution(object):
    def isBalanced(self,root):
        if self.banlanceTree(root) == -1: return False
        return True

    def banlanceTree(self, root):
        if not root: return 0

        lH = self.banlanceTree(root.left)
        if lH == -1: return -1
        rH = self.banlanceTree(root.right)
        if rH == -1: return -1
        if abs(lH - rH) > 1: return -1

        return 1 + max(lH, rH)
```