## 二叉树翻转

### 思路：
利用二叉树的遍历方法进行遍历，每次遍历处理节点时，都对节点的左右子节点进行交换。可采用的遍历方法（前序，后序，层序）均可。实际上中序遍历也可以，但是在bfs的时候实际会多交换几次，使用改造版本的中序遍历也可以实现。


### 实现方法

**遍历方法有三种（栈，递归（dfs，bfs），标记法），具体可以看[树相关基础知识](./1.%20树相关基础知识.md)**

#### 前序遍历 + 翻转 + 栈

```python
  class Solution:
    def preTraverse(root):
      if not root: return None
      stack = [root]

      while stack:

        node = stack.pop()
        node.left, node.right = node.right, node.left
        if node.right: stack.append(node.right)
        if node.left: stack.append(node.left)
      
      return root
```
#### 后序遍历 + 翻转 + 递归

**注意：** 后序遍历翻转不能用stack实现，因为没有创建新root，返回的是原root翻转，我们之前写的stack的后序遍历需要返回一个新result，生成的结果是（根右左）进行reverse后才是（左右根），而对root进行reverse完全没有必要。
```python
  class Solution:
    def posTraverse(root):
      if not root: return None

      def dfs(root):
        if not root: return root
        dfs(root.left)
        dfs(root.right)
        root.left, root.right = root.right, root.left
        return root
      
      return dfs(root)

        
```
#### 层序遍历  + 翻转 + 队列
```python
class Solution:
  def layerTraverse(root):
    queue = deque([root]) if root else deque()
    while queue:
      for _ in range(len(queue)):
        node = queue.popleft()
        node.left, node.right = node.right, node.left
        if node.left:
          queue.append(node.left)
        if node.right:
          queue.append(node.right)
    return root

```

#### 后序遍历 + 翻转 + 标记法
```python
class Solution:
  def posTraverse(root):
    if not root: return root
    stack = [root]

    while stack:
      node = stack.pop()
      if node == None:
        realNode = stack.pop()
        realNode.left, realNode.right = realNode.right, realNode.left
      else:
        stack.append(node)
        stack.append(None)
        if node.right: stack.append(node.right)
        if node.left: stack.append(node.left)
    return root
```
