## 树

### 树的结构
```python
# 链式存储
class TreeNode:
    def __init__(self, val, left = None, right = None):
        self.val = val
        self.left = left
        self.right = right

```
### 树的种类
#### 满二叉树
如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。满二叉树，
- 若深度为k，有2^k-1个节点的二叉树。
#### 完全二叉树
在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。
- 最底层为第 h 层（h从1开始），则该层包含 1~ 2^(h-1) 个节点。
#### 搜索二叉树
一颗二叉树中，根节点左边的节点总是小于根节点，根节点右边的节点总是大于根节点
- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树
#### 平衡二叉树
又被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：
- 它是一棵空树或者它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

### 树的基本概念

**节点的度：** 一个节点中含有的子树的个数

**叶节点/终端节点：** 度为0的节点（无子树节点）

**父节点/双亲节点：** 某个节点有子节点，这个节点就是子节点的父节点/双亲节点

**孩子节点/子节点：** 一个节点含有子树的根节点是这个节点的孩子节点/子节点

**兄弟节点：** 具有同一个父节点的节点互为兄弟节点

**节点的层次：** 根节点的层次开始为1，往下数

**树的高度或深度：** 叶子节点的层次数

**堂兄弟节点：** 父节点的双亲节点为同一节点

**节点的祖先：** 从根到该节点所经分支上的所有节点

**子孙：** 以某节点为根的子树中任一节点都称为该节点的子孙


### 树的遍历

#### 递归法

**思路：**
* 1. 递归考虑三个点：
- 递归的入参和返回值
- 终止条件
- 单层递归的逻辑部分

* 2. 前序遍历
- 根左右
**代码：**
```python

class Solution:
    def traversal(self, root: TreeNode) -> List[int]:
        res = []

        def dfs(node):
            # 终止条件
            if node is None:
                return;
            # 记录当前根节点
            res.append(node.val)
            # 遍历左
            dfs(node.left)
            # 遍历右
            dfs(node.right)

        dfs(root)
    return res
```

#### 迭代法

**思路：**
- 栈的性质：先进后出
- 树的前中后遍历法则
- 前序遍历：根左右，先处理根节点，再左，再右。所以在入栈的时候，需要先入栈右再入栈左
- 中序遍历：不同于前序，中序遍历，左根右。所以需要从根节点开始一直找左子树入栈，直到左到达叶子节点，回到根节点再去入栈右子树
- 后序遍历：左右根，可以考虑根右左然后进行reverse来实现。根右左怎么实现呢，其实就是前序遍历入栈顺序变成先入栈左再入栈右

```python 根左右
class Solution:
    def preOrderTraversal(self, root) -> List[int]:
        if not root: return []
        stack = [root]
        result = []
        while len(stack):
            node = stack.pop()
            result.append(node.value)
            if node.right: stack.append(node.right)
            if node.left: stack.append(node.left)
        return result
```

```python 左根右
class Solution:
    def inorderTraversal(self, root) -> List[int]:
        if not root: return []
        stack = []
        result = []
        cur = root
        while cur or stack:
            # 先访问到最底层的左叶子节点
            if cur:
                stack.append(cur)
                cur = cur.left
            else:
                cur = stack.pop()
                result.append(cur.value)
                cur = cur.right
        return result
```

```python 左右根
class Solution:
    def posOrderTraversal(self, root):
        if not root: return []
        stack = [root]
        result = []
        while len(stack):
            node = stack.pop()
            result.push(node.value)
            if (node.left) stack.append(node.left)
            if (node.right) stack.append(node.right)
        # 逆序
        return result[::-1]
            
```

#### 标记法

##### 使用Null进行标记
**思路：**
- 使用一个空指针Null放在已经处理过的节点的后面，子节点入栈按照遍历顺序入栈，下面以后序遍历为例子（左右根）
- 1. 把根节点放入stack中
- 2. 根节点入栈，紧接着入栈空指针NUll
- 3. 先处理右节点入栈，再处理左节点入栈
- 4. 左节点出栈，紧接着入栈左节点，入栈空指针Null（假设左子节点无子节点了）
- 5. Null出栈，出栈左节点进行记录。
- 6. 出站右节点，右节点入栈，入栈空指针Null。（假设右子节点无子节点了）
- 7. Null出栈，出栈右节点进行记录。

```python 后序遍历-左右根
class Solution:
    def posOrderTraversal(self, root) -> List[int]:
        values = []
        stack = []
        if root: stack.append(root)
         while stack:
            node = stack.pop()

            if (node == None) :
                cur = stack.pop()
                values.append(cur.val)
            else:
                stack.append(node)
                stack.append(None)

                if node.right:
                    stack.append(node.right)
                if node.left:
                    stack.append(node.left)
        return values
```
##### 使用Boolean进行标记
**思路：**
- 根据顺序，来放入遍历节点值，用一个Boolean进行标记某个节点他的左右子树是否被处理完毕，没有处理完毕就按顺序加入栈即可。下面以中序遍历（左根右为例子）
- 1. 把根节点放入stack中，标记为未遍历
- 2. 对根节点进行处理，根据栈的性质，先加入右节点（标记未处理），再入栈自己（标记被处理），最后加入左节点（标记未处理）
```python 中序遍历-左根右
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        values = []
        # stack中多存入一个Boolean值作为标记
        stack = [(root, False)] if root else [] 

        while stack:
            node, visited = stack.pop()
            
             # visited 为 True，表示该节点和两个儿子的位次之前已经安排过了，现在可以收割节点了
            if visited:
                values.append(node.val)
                continue

            # visited 当前为 False, 表示初次访问本节点，此次访问的目的是“把自己和两个儿子在栈中安排好位次”。
            # 中序遍历是'左中右'，右儿子最先入栈，最后出栈。
            if node.right:
                stack.append((node.right, False))
            
             # 把自己加回到栈中，位置居中。同时，设置 visited 为 True，表示下次再访问本节点时，允许收割
            stack.append((node, True))

            if node.left:
                stack.append((node.left, False))

        return values
```